%thesis.tex 
%Model LaTeX file for Ph.D. thesis at the 
%School of Mathematics, University of Edinburgh

\documentclass[11pt,twoside,openright]{report} 

%\usepackage{epsf}
\usepackage{amsmath}
\usepackage{color}
\usepackage{natbib}
\usepackage{framed}
%\usepackage{cite}
\usepackage{tikz}
\usepackage{tikz-cd}

\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{amsthm}
%\RequirePackage{algorithmic}
%\RequirePackage{algorithm}
%\RequirePackage{theorem}
%\RequirePackage{eucal}
\RequirePackage{color}
\RequirePackage{url}
\RequirePackage{mdwlist}

\RequirePackage[all]{xy}
\CompileMatrices
%\RequirePackage{hyperref}
\RequirePackage{graphicx}
%\RequirePackage[dvips]{geometry}

\usepackage{xcolor}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage[caption=false]{subfig}
\usepackage{enumerate}
\usepackage{mathrsfs}


%\usepackage{epstopdf} % to include .eps graphics files with pdfLaTeX

%\usepackage[pdfpagelabels,pdftex,bookmarks,breaklinks]{hyperref}

\definecolor{darkblue}{RGB}{0,0,127} % choose colors
\definecolor{darkgreen}{RGB}{0,150,0}
%\hypersetup{colorlinks, linkcolor=darkblue, citecolor=darkgreen, filecolor=red, urlcolor=blue}
%\hypersetup{pdfauthor={Simon Burton}}
%\hypersetup{pdftitle={Foo Foo}}

\usepackage[normalem]{ulem}

\usepackage{setspace}   %Allows double spacing with the \doublespacing command

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\newcommand{\Eref}[1]{(\ref{#1})}
%\newcommand{\Fref}[1]{Fig.~\ref{#1}}
%\newcommand{\Aref}[1]{Appendix~\ref{#1}}
\newcommand{\SRef}[1]{section~\ref{#1}}


\def\Complex{\mathbb{C}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
%\def\Ham{\mathcal{H}} % meh..
\def\Ham{H}
\def\Pauli{\mathcal{P}}
\def\Spec{\mbox{Spec}}
\def\Proveit{{\it (Proof??)}}
\def\GL{\mathrm{GL}}
\def\half{\frac{1}{2}}
\def\Stab{S}


\newcommand{\ket}[1]{|{#1}\rangle}
\newcommand{\expect}[1]{\langle{#1}\rangle}
\newcommand{\bra}[1]{\langle{#1}|}
\newcommand{\ketbra}[2]{\ket{#1}\!\bra{#2}}
\newcommand{\braket}[2]{\langle{#1}|{#2}\rangle}

%\newcommand{\todo}[1]{\textcolor{red}{#1}}

\def\smbox#1{\ \ \mbox{#1}\ \ }



\newcommand{\Field}{\mathcal{F}}
\def\Im{\mathrm{im}}
\def\Ker{\mathrm{ker}}
\def\Dim{\mathrm{dim}}
\def\euler{\chi}


\title{Non-Abelian Quantum Codes}
\author{Simon David Burton}
\date{2016}

\usepackage[phd]{edmaths}

\begin{document}

\maketitle

%\doublespacing
%\onehalfspacing

\declaration

%\dedication{To X Y Z}

\tableofcontents

\chapter{Quantum Codes}

%\chapter{A Homological Perspective on Quantum Codes}
%\input{stabilizer.tex}



We begin our journey with a consideration of ``size'', or ``counting''.
To count the size of something $A$ we write $\euler(A).$
Size is \emph{additive} in the sense of 
$\euler(A\cup B) = \euler(A) + \euler(B)$ except that
$A$ and $B$ may have intersection.
In this case we would have counted the 
size of the intersection twice and so we modify this formula as
$$
    \euler(A\cup B) = \euler(A) + \euler(B) - \euler(A\cap B).
$$
We can continue this idea to find the
size of the union of three pieces
\begin{center}
\includegraphics{pic-ABC.pdf}
\end{center}
In this case the formula reads:
\begin{align}\label{EulerAddSub}
\euler(A\cup B\cup C) = \ &\euler(A) + \euler(B) + \euler(C)  \nonumber \\
                     &- \euler(A\cap B) - \euler(A\cap C) - \euler(B\cap C) \nonumber \\
                     &+ \euler(A\cap B \cap C).
\end{align}
The point here is the alternating signs:
each time we try to count a size we overcount by
one intersections worth, subtracting those intersections
goes too far in the opposite direction and so we need
to add intersections of intersections, and so on.

We now wish to apply this idea to count the
size of a sphere. The trick here is to tile the
sphere with the faces of a cube:
\begin{center}
\includegraphics{pic-cube.pdf}
\end{center}
So we have six faces and one might suggest that 
$\euler(S^2)=6$ but these are closed faces, so they
intersect on their edges, of which we have 12.
But these edges intersect at vertices and there are
8 of these. 
We extend the above formula \Eref{EulerAddSub} to calculate:
$$
    \euler(S^2) = 6 - 12 + 8 = 2.
$$
So the sphere has ``size'' two!
The magic here is that any other convex polyhedron would give
the same answer of two.
This, of course, is known as the \emph{Euler characteristic},
and for a sphere this is indeed two.
\footnote{This approach to defining Euler characteristic is
discussed in the fascinating book \cite{Klain1997}.}

We repeat this calculation for another surface, a torus.
\begin{center}
\includegraphics[width=1.0\columnwidth]{pic-torus.pdf}
\end{center}
This time we use four faces, eight edges and four vertices:
$$
    \euler(S^1\times S^1) = 4 - 8 + 4 = 0.
$$

The Euler characteristic has many equivalent definitions,
and we now turn to one of these, which is the idea of a homology.
This theory goes back to Poincar\'e who was trying to
deal with topological issues as they arise in complex analysis~\cite{Lefschetz1970}.
%The first step is to consider vector spaces ...

We are going to replace sets of things by vector
spaces whose basis is the original set.
And just to keep things simple we will 
take our vector spaces over the finite field with
two elements $\Field=\{0, 1\}.$
%That is, we use mod 2 arithmetic when counting things.
This has the distinct advantage
of eliminating all sign errors!

From the set of faces we form a vector space
$C_2$ with basis the set of faces.
Similarly, the one-dimensional pieces are the basis of $C_1$
and the zero-dimensional pieces are the basis of $C_0$:
\begin{align*}
    C_2 &: \mbox{faces},\\
    C_1 &: \mbox{edges},\\
    C_0 &: \mbox{vertices.}
\end{align*}
The formula for Euler characteristic now reads:
\begin{align}\label{EulerEq}
    \euler(C_{\bullet}) = \mbox{dim}(C_2) - \mbox{dim}(C_1) + \mbox{dim}(C_0).
\end{align}
But now things get more interesting,
because we have the following linear operators:
\begin{align}\label{Sequence}
    C_2 \xrightarrow{\ \ \partial_2\ \ } C_1 \xrightarrow{\ \ \partial_1\ \ } C_0.
\end{align}
These are defined to take the ``boundary'' of a shape. 
The operator $\partial_2$ gives the boundary of a face $f\in C_2$
which is just the sum of edges incident to (contained by) that face:
$$
    \partial_2(f) = \sum_{\substack{e\in \text{edges},\\e\sim f}} e.
$$
where we use $\sim$ to indicate incidence, and we extend
$\partial_2$ to all of $C_2$ by linearity.
Similarly, $\partial_1$ is defined to take an edge
to the sum over its vertex endpoints:
$$
    \partial_1(e) = \sum_{\substack{v\in \text{vertices},\\v\sim e}} v.
$$

Now with a small amount of thought one finds that 
$$
    \partial_1 \circ \partial_2 = 0.
$$
This is because each vertex around a face gets counted twice,
and this is zero in $\Field$-linear arithmetic.
\begin{center}
%\includegraphics[width=1.0\columnwidth]{pic-bdy.pdf}
\includegraphics{pic-bdy.pdf}
\end{center}
In other words, the boundary of the boundary is empty!
Or equivalently,
$$
    \Im(\partial_2) \subset \Ker(\partial_1).
$$
%We call the subspace $\Ker(\partial_1)$ the \emph{cycles}
%of $C_1$. 
The subspace $\Ker(\partial_1)$ of $C_1$
will be sums of edges that form closed loops, and we
call these \emph{cycles}.
The subspace $\Im(\partial_2)$ is the space of \emph{boundaries}.
So the above formula
says the space of boundaries is contained within the space of cycles.
This allows us to define the following quotient,
known as the first \emph{homology} group:
$$
    H_1 := \Ker(\partial_1) / \Im(\partial_2).
$$
These are the cycles modulo boundaries.

With a bit more work we can extend the above sequence \Eref{Sequence} to
$$
  0 \xrightarrow{\ \ \partial_3\ \ } 
    C_2 \xrightarrow{\ \ \partial_2\ \ } 
    C_1 \xrightarrow{\ \ \partial_1\ \ } 
    C_0 \xrightarrow{\ \ \partial_0\ \ } 0
$$
so that $\partial_i \circ \partial_{i+1}=0$ 
for $i=0,1,2$
and then define
$$
    H_i := \Ker(\partial_i) / \Im(\partial_{i+1}),\ \ \ \mbox{for}\ \ \ i=0,1,2.
$$

Now we have a new formula for the Euler characteristic,
\begin{align}\label{EulerHom}
    \euler(H_{\bullet}) = \mbox{dim}(H_2) - \mbox{dim}(H_1) + \mbox{dim}(H_0),
\end{align}
which follows from
%from the homology condition
%$\partial_i \circ \partial_{i+1}=0$  and
an application of the rank-nullity theorem to
equation \Eref{EulerEq}.

Going back to the torus example, with four faces,
eight edges and four vertices:
\begin{center}
\includegraphics{pic-torus-hom.pdf}
\end{center}
we see that the sum over all faces in $C_2$
has zero boundary,
$$
    \partial_2(\sum_{f\in\text{faces}} f) = 0
$$
and this is the only vector with zero boundary so that
that $\Dim(H_2)=1$.
The space $H_1$ is two dimensional, with representative
cycles given by a vertical or horizontal loop of edges.
Finally, the space $H_0$ is one dimensional: these
are single points.
Putting this together we get
$$
    \euler(S^1\times S^1) = 
    \mbox{dim}(H_2) - \mbox{dim}(H_1) + \mbox{dim}(H_0) = 1-2-1 = 0,
$$
which agrees with our previous calculation for the Euler
characteristic of the torus.

%Because we have $\partial_3=0$ and $\partial_0=0$ this formula
%becomes
%\begin{align}
%    \euler(H_{\bullet}) = \Dim(\Ker{\partial_2}) - \dim(H_1) + \dim(\Im{\partial).
%\end{align}

This is all great but what does it have to do with quantum codes?
Well, before we talk quantum it is worth first going over what we
mean by a code in the classical sense of the word.
We wish to communicate a single bit of information, 
but the communication channel we use suffers from random noise.
This noise acts to randomly toggle bits.
One way to mitigate against this effect is to just
send multiple copies of each bit we wish to communicate.
For example, we send either $000$ or $111$.
Once again it is useful to think of this as a three
dimensional vector over $\Field.$
When the message is recieved any noise can be diagnosed
using the check matrix, $S:\Field^3\to\Field^3:$
$$
S = \left( \begin{array}{lll}
1&1&0\\
0&1&1\\
1&0&1
\end{array} \right).\quad
$$
The codewords belong in the kernel of this operator.
Any failure to be in the kernel is presumed to come
from a noise process.
Notice that this matrix is rank degenerate.
There is a reason for this: we can view it as
the boundary operator for the homology of a circle!
\begin{center}
\includegraphics{pic-circle-hom.pdf}
\end{center}
In this case, there is one bit for each of the three
edges, and the $S$ matrix will record a boundary vertex
between non-identical bits.
$$
  0 \xrightarrow{\ \ \ \ } 
    C_1 \xrightarrow{\ \ S=\partial_1\ \ } 
    C_0 \xrightarrow{\ \ \ \ } 0.
$$

Thinking of the finite field $\Field=\{0,1\}$ as a classical
bit would suggest that the passage to quantum codes involves
taking superpositions over these two bit values.
Indeed this is what we do.
The two dimensional complex Hilbert space that we get
is known as a \emph{qubit}:
$$
    \Complex[\Field] = \{ \alpha \ket{0} + \beta \ket{1}, \ \ \alpha,\beta\in \Complex \}.
$$
Notice how we put the $\Field$-linear values inside the ket.
Taking $n-$fold tensor products
of a qubit corresponds to superpositions over
$n$ dimensional $\Field$-linear values.
This basis we call the \emph{computational basis.}

Using this basis, we write matrices for 
the two important operators, Pauli X and Z:
$$
X = \left( \begin{array}{ll}
0&1\\
1&0\end{array} \right),\quad
Z = \left( \begin{array}{rr}
1&0\\
0&-1\end{array} \right).
$$
These two operators generate the (real) single qubit Pauli group $\Pauli_1$
and $n$-fold tensor products generate the $n$-qubit Pauli group $\Pauli_n.$
We suppress the tensor symbol in products, for example
writing $XII$ for $X\otimes I\otimes I.$ Here $I$ is the single
qubit identity operator.

Now we take the classical repitition code and
try the following quantum version:
$$
    \alpha\ket{0} + \beta\ket{1} \mapsto \alpha\ket{000} + \beta\ket{111}.
$$
To detect any single bitflip error, such as
$XII, IXI$ or $IIX$ 
we measure the \emph{check} operators
$ ZZI, IZZ.$
The outcome of such measurements we call a \emph{syndrome}
because these serve to diagnose an error process.

However, bitflip errors are not the only unitary operators
that we would like to detect.
Indeed, any single bit phaseflip operator, $ZII, IZI$ or $IIZ$
has the effect
$$
    \alpha\ket{000} + \beta\ket{111} \mapsto \alpha\ket{000} - \beta\ket{111}
$$
which goes unnoticed by our syndrome measurements.
Effectively we still have a classical code.

In order to move towards the solution to this problem,
we examine more closely the action of the check operators.
Given any state 
$$
    \ket{\psi} = \alpha\ket{000} + \beta\ket{111}
$$
we have 
$$
    g \ket{\psi} = \ket{\psi}
$$
for $g \in \{III, ZZI, IZZ, ZIZ\}.$
In other words, $\ket{\psi}$ is \emph{stabilized}
by the group generated by $ZZI$ and $IZZ.$
This motivates the following definition.
A \emph{stabilizer code} is 
specified by a commutative subgroup $S$ of $\Pauli_n$
such that $-I\notin S.$

It turns out that we can construct a stabilizer code 
from a two dimensional homology. We show how
this works by 
using the above example of torus homology.
Here we separately number
the faces, edges and vertices as
\begin{center}
\includegraphics{pic-torus-count.pdf}
\end{center}
Using this ordering 
the boundary operator matrices are
\begin{align*}
S_X = \partial_2^{\top} &= \left( \begin{array}{cccccccc}
1&1&1&.&.&1&.&.\\
1&.&1&1&.&.&.&1\\
.&1&.&.&1&1&1&.\\
.&.&.&1&1&.&1&1
\end{array} \right),\\
S_Z = \partial_1 &= \left( \begin{array}{cccccccc}
1&1&.&1&1&.&.&.\\
.&1&1&1&.&.&1&.\\
1&.&.&.&1&1&.&1\\
.&.&1&.&.&1&1&1
\end{array} \right).
\end{align*}

The homology condition $\partial_1\partial_2 = 0$ is
exactly the commutativity requirement $S_Z S_X^\top = 0$ for
a stabilizer code.

%\[
%\begin{tikzcd}
%\Field^n \arrow{r}{G_z} \arrow[swap]{d}{P} & \Field^{|G_Z|} \arrow{d}{Q} \\
%\Field^n \arrow{r}{G_z} & \Field^{|G_Z|} 
%\end{tikzcd}
%\]
$$
    \Field^{m_X} \xrightarrow{\ \ S_X^\top\ \ } 
    \Field^{n} \xrightarrow{\ \ S_Z\ \ } 
    \Field^{m_Z}
$$

To see the error correction process more vividly, we expand the
code dimensions.
Here we show a $m_X = 5\times 5$ tiling of the torus.
There are two edges per tile, so this code has $n=50$ qubits.

Here we show a noise process that acts by bitflip errors
and the resulting syndrome.
The noise process acts on qubits, this is a vector in $\Field^n:$
$$
    c \in \Field^n = C_1.
$$
So the error process is represented as some collection of edges.
The syndrome operator $S_Z$ gives the boundary of these
edges, shown as black vertices below.
The error correction procedure takes these boundary vertices
as input and attempts to reconstruct the most likely collection of
edges with this boundary. This then is the operator $c'\in\Field^n$
that is applied to correct the error.
Note that $c+c'$ is a cycle because the vertices of $c$ and $c'$ cancel out.
If the resulting operator $c+c'$ is in the image of $S_X,$
ie. a boundary, then the error correction has succeeded.
\begin{center}
\includegraphics[width=1.0\columnwidth]{pic-toric-suc.pdf}
\end{center}

Otherwise, $c+c'$ is not a boundary and represents a non-trivial
operator in $H_1$ and will therefore alter the encoded qubits:
\begin{center}
\includegraphics[width=1.0\columnwidth]{pic-toric-fail.pdf}
\end{center}

Phase flip errors.
Given any homology $\partial_1 \partial_2 = 0$
we get another homology by taking the transpose:
 $\partial_2^\top \partial_1^\top = 0.$

We can also build a Hamiltonian operator:
$$
    H = \sum_{s\in S} s.
$$
Note that in this thesis we use a neg-Hamiltonian convention,
so that the groundspace belongs to the largest eigenvalue.
For stabilizer codes $S$ this Hamiltonian is easily diagonalizable.
\begin{center}
\includegraphics[width=0.8\columnwidth]{pic-toric-liquid.pdf}
\end{center}

% ------------------------------------------------------------------

\begin{center}
* \ \ \ \ \ \ \ \ \ \ * \ \ \ \ \ \ \ \ \ \ *
\end{center}

There are two approaches to non-Abelian codes
explored in this thesis.
The first involves relaxing the commutativity
of the Hamiltonian terms.
These are the gauge code Hamiltonians discussed in chapter 2.
While these Hamiltonians are no longer easily diagonalizable,
we still find the stabilizers playing an important role.

The second approach to non-Abelian codes is more familiar
from an algebraic topology perspective. 
A practitioner of these arts would likely describe
the fundamental group of a space as being the non-Abelian 
version of its homology. And this is indeed the direction
we take as we describe the theory of anyons and modular
functors in chapter 3 and then go on to show how
error correction can be applied to these systems in
chapter 4.
In the abelian theory the following two
processes are equivalent (homologous), but for
general anyon theories this is not the case.
\begin{center}
\includegraphics[width=0.5\columnwidth]{pic-toric-nonab.pdf}
\end{center}

\begin{center}
* \ \ \ \ \ \ \ \ \ \ * \ \ \ \ \ \ \ \ \ \ *
\end{center}

It seems that physics has a long history of surprising encounters
with advanced mathematical concepts,
long after the mathematicians
themselves have finished being excited by them.
This would suggest the following algorithm for
success in theoretical physics:
\begin{enumerate}
\item look at what mathematicians were getting excited about several decades ago,
\item ???
\item profit!
\end{enumerate}
This is somewhat the philosophy of the present thesis.
The downfall of this is perhaps that some concepts are
elucidated in an overly technical manner. However, the
author feels this approach to be useful as it makes contact
with a shared mathematical language.

\chapter{Representations and Spectra of Gauge Code Hamiltonians}

\input{repr.tex}


\chapter{A Short Guide to Anyons and Modular Functors}

\input{guide.tex}


\chapter{Error Correction in a Non-Abelian Topologically Ordered System}

\input{supplement.tex}


%\appendix
%\chapter{First Appendix}

\bibliography{refs}{}
\bibliographystyle{abbrv}



\end{document}
